# -*- coding: utf-8 -*-
"""Dataset_Preparation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/priyanin/dataset-preparation.1965c769-f52d-416e-9c11-987aff04c837.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20251119/auto/storage/goog4_request%26X-Goog-Date%3D20251119T063158Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3Db019810e8c81653e1b497eec7f77c5194c898d1849a81a087137e28b65286b1f5a1880c4cdeb90c4cad9574636a186a177d47ea6433987c69fea15a1bbc45f2432eb565469e97c599a070ede4ea80b260f19db02fcfb5928b4b41fc7c9358a235c923904cd6c3a8cf4befe3f4db45899760e5db9fc03f0269c3b73289a84ce1b3f5faf4fba6473650af8129c7e32bbf8116c5a6372216ea15a967598e535fba3a6fdb32a32d037ece9e84facb0333bf155d12b51426201ee27f5290bd849a03164304ef573b25782e463bfb9813a5cb6e65730cffb0c8f55ceda91f0725176933f70b0e8d79e2d3ef87a1b032bcc59a9b452e44982715613ba26f582ed7e76bd
"""
import random
import math
import os
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from PIL import Image

# %% [code]
class CelebAMaskedDataset(Dataset):
    def __init__(self, root_dir, transform=None, mask_ratio=0.2, split="train", train_ratio=0.8, test_ratio=0.2, seed=42):
        assert split in ["train", "test"]

        self.root_dir = root_dir
        self.transform = transform
        self.mask_ratio = mask_ratio
        
        img_list = sorted(os.listdir(root_dir))

        np.random.seed(seed)
        np.random.shuffle(img_list)

        N = len(img_list)
        train_end = int(N * train_ratio)

        if split == "train":
            self.img_list = img_list[:train_end]
        else:
            self.img_list = img_list[train_end:]

    def __len__(self):
        return len(self.img_list)

    def __getitem__(self, idx):
        img_path = os.path.join(self.root_dir, self.img_list[idx])
        image = Image.open(img_path).convert("RGB")
        if self.transform:
            image = self.transform(image)
        mask = self.generate_brush_mask(image.shape[1:], self.mask_ratio)
        # mask = torch.from_numpy(mask).float().unsqueeze(0)
        masked_image = image * mask
        return masked_image, mask, image


    def generate_brush_mask(self, size, ratio, max_strokes=10, device="cpu"):
        """
        Generates a free-form irregular mask (brush strokes)
        covering approximately 'ratio' of the image.
        
        size  : (H, W)
        ratio : mask ratio (0.05 → 5% pixels masked)
        """
    
        H, W = size
        mask = torch.zeros((H, W), device=device)
    
        total_pixels = H * W
        target_pixels = int(total_pixels * ratio)  # how many pixels must be masked
    
        # Draw strokes until mask covers desired number of pixels
        while mask.sum().item() < target_pixels:
    
            num_strokes = random.randint(1, max_strokes)
    
            for _ in range(num_strokes):
                # Random stroke settings
                x, y = random.randint(0, W-1), random.randint(0, H-1)
                length = random.randint(H//10, H//3)
                angle = random.uniform(0, 2*math.pi)
                brush_w = random.randint(10, 40)
    
                # Draw stroke
                for i in range(length):
                    nx = int(x + i * math.cos(angle))
                    ny = int(y + i * math.sin(angle))
    
                    if 0 <= nx < W and 0 <= ny < H:
                        y1 = max(0, ny - brush_w)
                        y2 = min(H, ny + brush_w)
                        x1 = max(0, nx - brush_w)
                        x2 = min(W, nx + brush_w)
                        mask[y1:y2, x1:x2] = 1.0  # brushed area
    
                    # slightly rotate the brush direction
                    angle += random.uniform(-0.2, 0.2)
    
                # stop early if target is reached
                if mask.sum().item() >= target_pixels:
                    break
    
        return (1 - mask).unsqueeze(0).float()   # 1 for visible, 0 for holes


    def generate_mask(self, size, ratio):
        H, W = size
        # 1 with probability (1−ratio), 0 with probability ratio
        mask = (torch.rand(H, W) > ratio).float().unsqueeze(0)
        # H, W = size
        # mask = np.ones((H, W), dtype=np.float32)
        # num_mask = int(H * W * ratio)
        # idx = np.random.choice(H*W, num_mask, replace=False)
        # mask[np.unravel_index(idx, (H, W))] = 0.0
        return mask
